https://www.youtube.com/watch?v=nqowUJzG-iM&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go

##Dynamic Programming - 
Dynamic Programming is mainly an optimization over a plain recursion. In DP we memorize the result of recursive function of some specific state, 
which can then be later accessed to solve other sub-problems.

DP = Recursion -> Memozation -> top down approach 

Knapsack problem statement - Given a bag, and some items(with weight and value of each item) and max weight capacity of the bag. Add items to the bag which can give max profit.

Types of knapsack -
1. 0-1 knapsack - In this we can either put an item in bag or we cant put it in bag
2. fractional - In this we can put some fraction of the item to achieve max profit 
3. unbounded - Similar as 0-1 but any item can be added multiple times


Knapsack problem exmaple - 
        Input - 
          Weight[] - [1, 3, 4, 5]
          Value[] -  [1, 4, 5, 7]
          Total max Weight of bag - 10
          total items count - 4
        Output - Max Profit 
  
      Recursive Approach - 
        Any recursive call looks like this - 
          
        func myRecursiveFunc(inputs) -> outputs {
          [Base Condition] - Think of the smallest valid input 
          [Choice Diagram]
        }
      
        func knapsack(weightArr: Array<Int>, valueArr: Array<Int>, totalWeight: Int, itemsCount: Int) -> Int {
          
          // Base condition 
          if (totalWeight == 0 ||  itemsCount == 0) {
              return 0
          }
          
          [Choice Diagram]
        }
